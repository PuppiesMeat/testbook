{"./":{"url":"./","title":"手机+眼镜方案","keywords":"","body":"Nothing README "},"res/mobile_glass/ChangeLog.html":{"url":"res/mobile_glass/ChangeLog.html","title":"变更记录","keywords":"","body":"ChangeLog 首次创建文档 文档责任人 何顺 版本记录 修订日期 撰稿人/修订人 变更记录及说明 V1.0 2020.09.04 何顺 首次创建文档 "},"res/mobile_glass/introduction.html":{"url":"res/mobile_glass/introduction.html","title":"简介","keywords":"","body":" 手机+眼镜方案 基础知识 眼镜使用限制 眼镜+手机方案接入说明 手机+眼镜方案 眼镜+手机方案可实现能力如下： 眼镜作为USB设备连接手机，通过眼镜可以获取到的数据如下： 眼镜Camera数据 眼镜按键事件 眼镜传感器事件 眼镜作为USB设备连接手机，支持双屏异显。 基础知识 以下开发知识点如不熟悉请参考相应链接进行学习了解。 USB主机 UVCCamera UVC全称：USB Video Class，可以认为就是外接摄像头 双屏异显 眼镜使用限制 眼镜作为USB设备双屏异显对手机机型有限制（各手机厂商对双屏异显实现不一致），目前仅支持华为部分支持DP输出机型（Mate10、Mate20、Mate30及对应Pro机型，P系列支持DP输出大概率也支持。 支持手机必备条件（可直接进行下面第三个步骤确认手机是否支持） 手机数据接口为TypeC接口 手机支持DP输出 使用Rokid测试Apk确认手机是否支持）以下条件任意一条不满足的手机都表明不支持此机型 是否正常供电：将眼镜盒手机使用数据线连接，带上眼镜，确认眼镜屏幕是否点亮。 显示是否正常：查看眼镜显示画面是否正常，一般显示界面是手机界面的镜像显示 眼镜+手机方案接入说明 请确认使用眼镜+手机方案需实现功能，再从以下方案中选择合适的接入方式。 使用眼镜硬件能力(Camera数据、按键事件、传感器事件、双屏异显)眼镜硬件功能 使用眼镜硬件能力+人脸识别、车牌识别 使用眼镜硬件能力+人脸识别、车牌识别+双屏异显 完整Demo 完整demo是将眼镜硬件能力、人脸识别、车牌识别、双屏异显串联起来的demo 眼镜硬件能力 人脸识别、车牌识别 双屏异显 "},"res/mobile_glass/glass_hw.html":{"url":"res/mobile_glass/glass_hw.html","title":"眼镜硬件功能","keywords":"","body":" 眼镜硬件功能说明 SDK集成步骤 眼镜USB主机信息说明 如何鉴别UsbDevice为Rokid眼镜 获取眼镜其他信息 摄像头数据 获取方式 眼镜按键 按键监听 按键说明 传感器 光线传感器 位于眼镜位置 获取光线传感器事件 距离传感器 位于眼镜位置 获取距离传感器事件 眼镜亮度调整 API 眼镜硬件功能说明 此部分功能包含： 眼镜信息获取 Camera数据获取 按键、传感器事件获取 SDK集成步骤 工程build.gradle配置maven仓库地址 allprojects { repositories { maven { url = 'https://dl.bintray.com/rokid/alliance/' } } } 模块build.gradle配置SDK依赖 implementation 'com.rokid.alliance.usbcamera:usbcamera:1.0.0.7' SDK依赖权限如下 private static final String[] REQUIRED_PERMISSION_LIST = new String[]{ Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO, Manifest.permission.CAMERA, Manifest.permission.READ_PHONE_STATE, } targetSdkVesion必需 defaultConfig { targetSdkVersion 27 } SDK使用 RKGlassDevice.RKGlassDeviceBuilder .buildRKGlassDevice() .withGlassSensorEvent(new GlassSensorEvent() { /** * 距离传感器你 * @param status true可认为是带上眼镜 唤醒光机 false可认为已摘下眼镜 熄灭光机 */ @Override public void onPSensorUpdate(final boolean status) { RKGlassDevice.getInstance().setBrightness(status ? 100 : 0);//可以根据距离传感器来判断眼镜是否处于佩戴状态，来调整光机的亮度节能 lSensorBar.setProgress(status ? 100 : 0); tvPSensor.post(() -> tvPSensor.setText(\"距离传感器状态: \" + status)); } /** * 前置光线传感器 * @param lux 最小值为0 */ @Override public void onLSensorUpdate(final int lux) { tvLSensor.post(() -> tvLSensor.setText(\"光线传感器: \" + lux)); } }) .withRKKeyListener(new RKKeyListener() { /** * 电源键键事件 * @param eventType {@link KeyEventType} */ @Override public void onPowerKeyEvent(final int eventType) { tvPower.post(() -> tvPower.setText(\"电源键事件: \" + eventToString(eventType))); } /** * 回退键事件 * @param eventType {@link KeyEventType} */ @Override public void onBackKeyEvent(final int eventType) { tvBack.post(() -> tvBack.setText(\"回退键事件: \" + eventToString(eventType))); } /** * 触控板事件 * @param eventType {@link RKGlassTouchEvent} */ @Override public void onTouchKeyEvent(final int eventType) { tvTouch.post(() -> tvTouch.setText(\"TouchBar事件: \" + eventToString(eventType))); } /** * 触控板向后滑动 */ @Override public void onTouchSlideBack() { tvSlide.post(() -> tvSlide.setText(\"向后滑动\")); } /** * 触控板向前滑动 */ @Override public void onTouchSlideForward() { tvSlide.post(() -> tvSlide.setText(\"向前滑动\")); } }) .build() .initUsbDevice(this, mPreview, new OnGlassConnectListener() { /** * 当用户授权眼镜权限后 将回调 * @param usbDevice {@link UsbDevice} * @param glassInfo {@link GlassInfo} */ @Override public void onGlassConnected(UsbDevice usbDevice, GlassInfo glassInfo) { tvDeviceInfo.post(() -> tvDeviceInfo.setText(\"Glass信息：vendorId:\" + usbDevice.getVendorId() + \" productId: \" + usbDevice.getProductId() + \" deviceName: \" + usbDevice.getDeviceName() + \" SN: \" + glassInfo.getSn())); lSensorBar.setProgress(RKGlassDevice.getInstance().getBrightness()); lSensorBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { // 调整光机亮度 范围0~100 RKGlassDevice.getInstance().setBrightness(progress); } @Override public void onStartTrackingTouch(SeekBar seekBar) { } @Override public void onStopTrackingTouch(SeekBar seekBar) { } }); } /** * 当眼镜断开连接时 */ @Override public void onGlassDisconnected() { tvDeviceInfo.post(() -> tvDeviceInfo.setText(\"Glass断开连接\")); } }); 眼镜USB主机信息说明 如果对USB主机设备不熟悉请先阅读USB主机 如何鉴别UsbDevice为Rokid眼镜 字段 类型 值 说明 VendorId int 1234 通过UsbDevice#getVendorId()获取 ProductId int 5678 通过UsbDevice#getProductId()获取 获取眼镜其他信息 获取方式，在RKGlassDevice#initUsbDevice(...)回调函数中，我们可以获取到眼镜的基本信息GlassInfo，字段说明如下： 字段 类型 说明 sn String 区分眼镜唯一标识序列号 typeId String 设备TypeId pcba String 设备PCBA编码 vSyncStatus boolean 设备VSync状态 opticalId String 可区分眼镜生产批次，其值目前有三个，分别是\"1\"、\"2\"、\"3\" 注意：opticalId区分眼镜批次后主要用于alignment对齐。alignment对齐可以理解为当对现实场景进行标注时，应用在眼镜屏幕的标注点与实际人眼看到的位置不一样，因此需要对屏幕标注的位置进行调整。根据眼镜生产批次的不同（我们认为同一批次的眼镜调整系数是一样的），通过opticalId进行区分。 摄像头数据 摄像头数据获取基于第三方开源库UVCCamera封装，UVC全称：USB Video Class，可以认为就是外接摄像头。 获取方式 初始化 监听camera数据回调 RKGlassDevice.getInstance().setOnPreviewFrameListener(bytes -> { //TODO }); 取消camera数据回调 RKGlassDevice.getInstance().removeOnPreviewFrameListener(AbstractUVCCameraHandler.OnPreViewResultListener: onPreviewFrameListener); 眼镜按键 眼镜按键包括回退键、电源键、触控板。 按键监听 获取方式 按键说明 按键类型一般分为单击、双击及长按类型，除此之外，触控板增加了向前滑动和向后滑动事件。 public interface RKKeyListener { /** * 电源键键事件 * @param eventType {@link KeyEventType} */ void onPowerKeyEvent(@KeyEventType int eventType); /** * 回退键事件 * @param eventType {@link KeyEventType} */ void onBackKeyEvent(@KeyEventType int eventType); /** * 触控板事件 * @param eventType {@link RKGlassTouchEvent} */ void onTouchKeyEvent(@KeyEventType int eventType); /** * 触控板向后滑动 */ void onTouchSlideBack(); /** * 触控板向前滑动 */ void onTouchSlideForward(); } @IntDef(value = {KeyEventType.SINGLE_CLICK, KeyEventType.DOUBLE_CLICK, KeyEventType.LONG_CLICK}) public @interface KeyEventType { /** * 单击事件 */ public static final int SINGLE_CLICK =1; /** * 双击事件 */ public static final int DOUBLE_CLICK =2; /** * 长按事件 */ public static final int LONG_CLICK =3; } 传感器 眼镜目前包含前置光线传感器和后缀距离传感器。 光线传感器 位于眼镜位置 获取光线传感器事件 获取方式 距离传感器 位于眼镜位置 获取距离传感器事件 获取方式 眼镜亮度调整 光机亮度调整的范围是[0,100]。建议配合距离传感器和光线传感器使用。 API RKGlassDevice.getInstance().setBrightness(int: brightness); int brightness = RKGlassDevice.getInstance().getBrightness(); "},"res/mobile_glass/ai.html":{"url":"res/mobile_glass/ai.html","title":"人脸、车牌识别","keywords":"","body":" 人脸sdk 人脸sdk集成 离线人脸识别 添加离线人脸数据 人脸sdk 人脸sdk主要功能包含人脸检测、人脸跟踪、人脸得分、人脸质量、离线人脸识别。 人脸sdk集成 如果双屏异显直接采用Rokid显示方案，也可以直接参考在线人脸识别集成 加载模型 函数： RKAlliance.getInstance().loadFaceModel(getApplicationContext(), new PreparedListener() { @Override public void onPrepared() { } 参数： 字段 | 类型 | 说明 ---- | ----- | ---- context | Context | ApplicationContext preparedListener | PreparedListener | 加载模型成功回调函数 初始化人脸sdk 函数： RKAlliance.getInstance().initFaceSDK(getApplicationContext(), roi, new PreparedListener() { @Override public void onPrepared() { } }); 参数： 字段 | 类型 | 说明 ---- | ----- | ---- context | Context | ApplicationContext preparedListener | PreparedListener | 初始化成功回调函数 注册人脸回调 函数： RKAlliance.getInstance().registerFaceListener(new Callback() { @Override public void onDataResult(RKFaceModel rkFaceModel, byte[] bytes) { } }); RKFaceModel： 字段 | 类型 | 说明 ---- | ----- | ---- width | int | 原始图片宽（可以理解为Camera出来的数据） height | int | 原始图片高 data | byte[] | 原始图片数据 faces | List | 对应图片包含的人脸 RKFaceDO： 字段 | 类型 | 说明 ---- | :-----: | ---- faceRectF | RectF | 人脸对应原图的位置 trackId | int | 人脸追踪id，每个id的生命周期为从检测到新的人脸开始到此人脸不存在摄像头画面 data | byte[] | 原始图片数据 quality | float | 人脸质量分，过滤掉非人脸图片建议quality>=40 faceScore | float | 人脸得分（相似度） recogBitmap | Bitmap | 人脸抠图 featid | String | 人脸特征，用于离线人脸。 离线人脸识别 添加离线人脸数据 人脸sdk集成 添加离线人脸 示例： ExtractFeatResult featResult = FaceDataManager.getInstance().extractFeat(Bitmap: bitmap); if (featResult.getResultCode() == 0) {//图片特征提取成功 FaceDataManager.getInstance().addPerson(Person: person, List featFileInfos, null, true);//添加到数据库 } API说明： ExtractFeatResult featResult = FaceDataManager.getInstance().extractFeat(Bitmap: bitmap); 参数： 字段 | 类型 | 说明 ---- | :-----: | ---- bitmap | Bitmap | 需要提取人脸特征的人脸照片（正脸） featResult | ExtractFeatResult | 提取特征的返回值 ExtractFeatResult： 字段 | 类型 | 说明 ---- | :-----: | ---- resultCode | int | 0为成功提取，其他为提取失败 resultMsg | String | 提取失败原因 ErrorCode errorCode = FaceDataManager.getInstance().addPerson(Person: person, List featFileInfos, String covertId, boolean needSave); 参数： 字段 | 类型 | 说明 ---- | :-----: | ---- person | Person | 添加人脸个人信息 featFileInfos | List | 添加人脸特征及保存图片路径集合(每个人可以添加多张图片) covertId | String | 封面id（与需要作为封面的照片featid一致），当识别到该人时UI将展示此coverId对应的照片 needSave | boolean | errorCode | ErrorCode | 添加人脸到数据库返回值 Person： 字段 | 类型 | 说明 ---- | :-----: | ---- name | String | 姓名 cardNo | String | 身份证号码 birthPlace | String | 出生地 tag | String | 标签（如逃犯等） isAlarm | boolean | 是否告警 FeatFileInfo： 字段 | 类型 | 说明 ---- | :-----: | ---- featId | String | 人脸图片特征id filePath | String | 人脸图片存储路径，用于识别展示 ErrorCode： 字段 | 类型 | 说明 ---- | :-----: | ---- code | int | 0为成功，其他为失败 msg | String | 添加失败信息 根据识别结果查询数据库 示例： final UserInfo info = FaceIdManager.getInstance().getUserInfoByFid(RKFaceDO.featid); 参数： 字段 | 类型 | 说明 ---- | :-----: | ---- featid | String | 识别到的人脸的特征id info | UserInfo | 从离线人脸数据库根据特征id查询到的人员信息 UserInfo： 字段 | 类型 | 说明 ---- | :-----: | ---- uid | String | 添加人脸生成的userid name | String | 添加人脸时输入的姓名 cardno | String | 添加人脸是输入的身份证号 nativeplace | String | 添加人脸时输入的住址信息 description | String | 添加人脸时输入的其他信息 isAlarm | boolean | 是否告警，添加人脸时输入 在线人脸识别 如果需要自行定义人脸识别UI交互，此部分可以仅作为参考。 集成Rokid maven库则不需要开发双屏异显，或者可以获取源码进行部分ui调整，集成方式如下： 车牌sdk 车牌sdk主要包含车牌号码识别功能。 车牌sdk集成 加载模型 函数： RKAlliance.getInstance().loadLPRModel(getApplicationContext(), new PreparedListener() { @Override public void onPrepared() { } }); 参数： 字段 | 类型 | 说明 ---- | ----- | ---- context | Context | ApplicationContext preparedListener | PreparedListener | 加载模型成功回调函数 初始化车牌sdk 函数： RKAlliance.getInstance().initPlateSDK(new PreparedListener() { @Override public void onPrepared() { } }); 参数： 字段 | 类型 | 说明 ---- | ----- | ---- preparedListener | PreparedListener | 初始化成功回调函数 注册车牌回调 函数： RKAlliance.getInstance().registerLPRCallback(new Callback() { @Override public void onDataResult(RKLPRModel rklprModel, byte[] bytes) { } }); RKLPRModel： 字段 | 类型 | 说明 ---- | ----- | ---- width | int | 原始图片宽（可以理解为Camera出来的数据） height | int | 原始图片高 lps | List | 所有检测到的车牌 RKLPRDO： 字段 | 类型 | 说明 ---- | ----- | ---- position | RectF | 车牌在原始图的位置 licensePlate | String | 车牌号码 score | float | 相似度 离线车牌识别 待更新 "},"res/mobile_glass/glass_ai_presentation.html":{"url":"res/mobile_glass/glass_ai_presentation.html","title":"双屏异显","keywords":"","body":" 双屏异显 双屏异显 此部分内容包含了双屏异显以及 "},"res/mobile_glass/demo.html":{"url":"res/mobile_glass/demo.html","title":"完整demo","keywords":"","body":" 完整Demo 完整Demo "}}